
// TODO: implement
// [x] import/export (with renames)
// [x] type creation
// [x] structs
// [ ] binary operator definitions eg: '+'
// [ ] for stmt maybe?
// [ ] function attributes
// [ ] lists as core types
//     [ ] native memory allocation
// [ ] threading
//     [ ] session-types



// language features:
//
// ## ATTRIBUTES ##
//
// attributes for variables:
//   def: value is defined in compile time. Can be opimizied
//     to hell and back.
//   const (default): value is imutable, but assumed to be unknown at
//     compile. Won't be optimized out.
//   var: value mutable whithin linear execution.
//     Typical variable behaviour.
//   static: its value won't be lost between function calls. A
//     static variable's value is stored in the data segment.
//   volatile: value is mutable, and can change between reads
//     during execution. No execution optimizations are
//     applied.
//
// attributes for functions:
//   fuction with an attribute 'a' requires that all its
//     arguments be at least as restrictive as 'a'.
//   def: function is computed and substituted by the return
//     value during compilation. Requires that its arguments
//     also have the def attribute.
//   const (default): requires that the function must be implemented in
//     code space, i.e. it can't be optimized out.
//   var: normal expected function behaviour. Can be
//     optimized out, or inlined.
//   volatile: The function executes every line in the written
//     order. No execution optimizations are applied.
//
//
// ## POLYMORPHISM ##
//
// // Explicit polymorphism is redundant.
// // The complexity of type-checking greatly outweighs, its type well-formedness.
// // Values can be passed polymorphically through anonymous addresses and casts.
// // After all a polymorphic function isn't necessarily programmed for ALL types.
// // Especially from a low-level point of view.
// Polymorphism is NOT redundant. Verbose and complex, possibly. So
// let's make it as little verbose and complex as possible.
// Polymorphism allows type agnostic functions to be called and
// not disrupt a strong typed context. That is well-typedness is not
// lost by otherwise calling type-less pointers (e.g. @). Making '@'
// an invalid type. A polymorphic sort function could have the
// following signature: "sort : [<a>] -> [<a>]".
//
// How do polymorphic functions behave in the prensence of overloads?
//     If a specific type implementation of  a function is equivalent
//     to a polymorphic implementation of a function with the same
//     name, the specific type case is always preferred. For example:
//     if a specific implementation of the 'sort' function for integers
//     exists, it is going to be preferred for sorting a list of
//     integers, instead of its polymorphic counterpart.
//
//
// ## PATTERN MATCHING ##
//
// Pattern matching (for types) can be achieve through function
//   overloading.
// Pattern matching (for values) could possibly be implemented.
//   Altough could possibly be implemented, through sugary syntaxed
//   switch case statements...

file : [s_export] [s_import] (g_stmt)*

s_export : "export" "{" signature_list "}" ";"
s_import : "import" NAME ["as" NAME] "{" signature_list "}" ";"
  signature_list : signature ("," signature)*

?g_stmt : s_empty | s_prog | s_func | s_type | s_enum
s_empty : ";"
s_prog  : signature "=" exp ";"
s_func  : signature e_block ";"
  signature : id [attr] ":" type
    attr : NAME
s_type  : NAME "::" type ";"
s_enum  : NAME "#" "{" enum_list "}" ";"
  enum_list : enum_elem ("," enum_elem)*
  enum_elem : NAME ["=" int_lit]

?type : t_union | t_func | basic_type
t_func  : param op_t_func type
  ?op_t_func : op_func | op_unord_func
    op_func : "->"
    op_unord_func : "?->"
  param : NAME basic_type
t_union : basic_type "||" type
?basic_type : t_addr | t_alias | t_struct | t_paren | t_arr //| t_sized 
t_addr   : basic_type "@"
t_struct : "{" type_list "}"
  type_list : signature ("," signature)*
t_alias  : NAME
t_paren  : "(" type ")"
t_arr    : basic_type "[" [int_lit] "]"
//t_sized  : int_lit

?stmt : s_decl | s_inf_decl | s_empty | s_write | s_ignore
      | s_while | s_do | s_ret | s_continue | s_break
s_decl     : signature "=" exp ";"
s_inf_decl : NAME "=" exp ";"
s_write    : "@" basic_exp "=" exp ";"
s_ignore   : exp ";"
s_while    : "while" basic_exp "do" e_block ";"
s_do       : "do" e_block "while" basic_exp ";"
s_ret      : "ret" [exp] ";"
s_continue : "continue" ";"
s_break    : "brake" ";"

exp : basic_exp+
// e_pipe : (e_app | basic_exp) "|>" exp
?basic_exp : e_block | e_lambda | e_member | e_read | e_if
           | e_array | e_closed | terminal
e_lambda : "\\" [":" type] "=" e_block
e_member : NAME "." (e_member | id)
e_read   : "@" basic_exp
e_closed : "(" exp ")"
e_if     : "if" basic_exp "then" basic_exp ["else" basic_exp]
e_array  : "{" exp_list "}"
  exp_list : exp ("," exp)*
e_block  : "{" stmt* "}"
//     | exp ":" type                     -> cast
// casts are to be defined like functions
// Unops and biops should be all defined as funcions

?terminal : id | int_lit | STRING | CHAR
?int_lit : HEX | BIN | DECIMAL | ZERO
?id : NAME | SYMBOL

DECIMAL : /[1-9][0-9]*/
HEX.2 : /0x[0-9a-fA-F]+/
BIN.2 : /0b[01]+/
ZERO : /0/

NAME : /[_a-zA-Z][_a-zA-Z0-9]*/
SYMBOL : /[^\w\s(){}\[\],.:;@!?]+/

STRING : /"([\S ])*?"/
CHAR : /'([\S ])*?'/

LINE_COMMENT : /\.\..*/

%ignore LINE_COMMENT
%ignore " "|"\t"|"\n"|"\r"
